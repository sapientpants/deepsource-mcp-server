/**
 * @jest-environment node
 */

import { expect } from '@jest/globals';
import { DeepSourceClient } from '../deepsource.js';
import { ErrorCategory } from '../utils/errors.js';

// Mock values
const PROJECT_KEY = 'test-project';
const API_KEY = 'test-api-key';

// Define a type for classified errors to avoid repetitive casting
interface ClassifiedError extends Error {
  category: ErrorCategory;
  originalError: Error;
  metadata: Record<string, unknown>;
}

describe('DeepSourceClient vulnerability error handling', () => {
  let client: DeepSourceClient;

  beforeEach(() => {
    client = new DeepSourceClient(API_KEY);
  });

  // We need to access private static methods for testing
  // @ts-expect-error - Accessing private static method for testing
  const handleVulnerabilityError = DeepSourceClient['handleVulnerabilityError'];

  // Helper function to bind the method to our client instance
  const handleError = (error: Error) => {
    return handleVulnerabilityError.bind(client)(error, PROJECT_KEY);
  };

  // Helper function for type-safe error assertion
  const assertClassifiedError = (thrownError: unknown): ClassifiedError => {
    if (!(thrownError && typeof thrownError === 'object' && 'category' in thrownError)) {
      throw new Error('Unexpected error type');
    }
    return thrownError as ClassifiedError;
  };

  describe('handleVulnerabilityError method', () => {
    it('should handle schema errors correctly', () => {
      // Create an error that will be classified as a schema error
      const error = new Error('Cannot query field "foo" on type "Query"');
      // Manually set properties to mock a GraphQL error
      Object.assign(error, {
        name: 'GraphQLError',
        message: 'Cannot query field "foo" on type "Query"',
        path: ['query', 'field'],
        extensions: { code: 'GRAPHQL_VALIDATION_FAILED' },
      });

      // Try to handle this error - it should throw with the appropriate message
      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.SCHEMA);
        expect(typedError.message).toContain('GraphQL schema error');
        expect(typedError.message).toContain('Cannot query field "foo" on type "Query"');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle auth errors correctly', () => {
      // Create an error that will be classified as auth error
      const error = new Error('Not authorized');
      Object.assign(error, {
        name: 'GraphQLError',
        message: 'Not authorized',
        extensions: { code: 'FORBIDDEN' },
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.AUTH);
        expect(typedError.message).toContain('Access denied');
        expect(typedError.message).toContain(PROJECT_KEY);
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle rate limit errors correctly', () => {
      // Create an error that will be classified as rate limit error
      const error = new Error('Too many requests');
      Object.assign(error, {
        name: 'GraphQLError',
        message: 'Too many requests',
        extensions: { code: 'TOO_MANY_REQUESTS' },
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.RATE_LIMIT);
        expect(typedError.message).toContain('Rate limit exceeded');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle timeout errors correctly', () => {
      // Create an error that will be classified as timeout error
      const error = new Error('Request timeout');
      Object.assign(error, {
        name: 'TimeoutError',
        message: 'Request timeout',
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.TIMEOUT);
        expect(typedError.message).toContain('Request timeout');
        expect(typedError.message).toContain('Try querying with pagination');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle network errors correctly', () => {
      // Create an error that will be classified as network error
      const error = new Error('Network error');
      Object.assign(error, {
        name: 'NetworkError',
        message: 'Network error',
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.NETWORK);
        expect(typedError.message).toContain('Network error');
        expect(typedError.message).toContain('check your network connection');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle server errors correctly', () => {
      // Create an error that will be classified as server error
      const error = new Error('Internal server error');
      Object.assign(error, {
        name: 'GraphQLError',
        message: 'Internal server error',
        extensions: { code: 'INTERNAL_SERVER_ERROR' },
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.SERVER);
        expect(typedError.message).toContain('Server error');
        expect(typedError.message).toContain('experiencing issues');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle not found errors correctly', () => {
      // Create an error that will be classified as not found error
      const error = new Error('Resource not found');
      Object.assign(error, {
        name: 'GraphQLError',
        message: 'Resource not found',
        extensions: { code: 'NOT_FOUND' },
      });

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.NOT_FOUND);
        expect(typedError.message).toContain('Resource not found');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });

    it('should handle uncategorized errors correctly', () => {
      // Create an error that doesn't fall into any specific category
      const error = new Error('Some unexpected error');

      try {
        handleError(error);
        expect(true).toBe(false); // This will fail if the code reaches here
      } catch (thrownError: unknown) {
        const typedError = assertClassifiedError(thrownError);

        expect(typedError.category).toBe(ErrorCategory.OTHER);
        expect(typedError.message).toContain('Unexpected error');
        expect(typedError.message).toContain('Some unexpected error');
        expect(typedError.originalError).toBe(error);
        expect(typedError.metadata).toEqual({ projectKey: PROJECT_KEY });
      }
    });
  });
});
