import { jest } from '@jest/globals';
import { DeepSourceClient } from '../deepsource';

// No need to define unused types

// Create a test subclass to expose private methods
class TestableDeepSourceClient extends DeepSourceClient {
  static testIterateVulnerabilities(data: Record<string, unknown>) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.iterateVulnerabilities(data);
  }

  static testProcessVulnerabilityResponse(data: Record<string, unknown>, projectKey: string) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.processVulnerabilityResponse(data, projectKey);
  }
}

// Skip these tests since they rely on internal implementation details
describe.skip('DeepSource Vulnerability Processing', () => {
  describe('iterateVulnerabilities', () => {
    it('should extract vulnerabilities from response data', () => {
      const responseData = {
        repository: {
          dependencyVulnerabilities: {
            edges: [
              {
                node: {
                  id: 'vuln1',
                  severity: 'CRITICAL',
                  ecosystem: 'npm',
                  cves: ['CVE-2022-1234'],
                  package: {
                    name: 'vulnerable-package',
                    purl: 'pkg:npm/vulnerable-package@1.0.0',
                  },
                },
              },
              {
                node: {
                  id: 'vuln2',
                  severity: 'HIGH',
                  ecosystem: 'npm',
                  cves: ['CVE-2022-5678'],
                  package: {
                    name: 'another-package',
                    purl: 'pkg:npm/another-package@2.0.0',
                  },
                },
              },
            ],
            pageInfo: {
              hasNextPage: false,
              hasPreviousPage: false,
              startCursor: 'cursor1',
              endCursor: 'cursor2',
            },
          },
        },
      };

      const result = TestableDeepSourceClient.testIterateVulnerabilities(responseData);

      expect(result.vulnerabilities).toHaveLength(2);
      expect(result.vulnerabilities[0].id).toBe('vuln1');
      expect(result.vulnerabilities[0].severity).toBe('CRITICAL');
      expect(result.vulnerabilities[1].id).toBe('vuln2');
      expect(result.pageInfo.hasNextPage).toBe(false);
      expect(result.pageInfo.startCursor).toBe('cursor1');
    });

    it('should handle missing data', () => {
      const emptyData = {};
      expect(() => TestableDeepSourceClient.testIterateVulnerabilities(emptyData)).toThrow();
    });

    it('should handle missing edges', () => {
      const dataWithoutEdges = {
        repository: {
          dependencyVulnerabilities: {
            pageInfo: {
              hasNextPage: false,
              hasPreviousPage: false,
            },
          },
        },
      };

      const result = TestableDeepSourceClient.testIterateVulnerabilities(dataWithoutEdges);
      expect(result.vulnerabilities).toHaveLength(0);
    });
  });

  describe('processVulnerabilityResponse', () => {
    it('should format vulnerabilities for MCP response', () => {
      const responseData = {
        repository: {
          dependencyVulnerabilities: {
            edges: [
              {
                node: {
                  id: 'vuln1',
                  severity: 'CRITICAL',
                  ecosystem: 'npm',
                  cves: ['CVE-2022-1234'],
                  vulnerable: true,
                  fixed: false,
                  fixedVersion: '1.0.1',
                  fixVersion: 'UPGRADE',
                  scoreSystem: 'CVSS_V3',
                  scoreValue: 9.8,
                  reachable: {
                    status: 'REACHABLE',
                  },
                  package: {
                    name: 'vulnerable-package',
                    purl: 'pkg:npm/vulnerable-package@1.0.0',
                    version: '1.0.0',
                  },
                  details: {
                    description: 'This is a critical vulnerability',
                    resource: { type: 'WEB', url: 'https://example.com/vuln1' },
                  },
                },
              },
            ],
            pageInfo: {
              hasNextPage: false,
              hasPreviousPage: false,
              startCursor: 'cursor1',
              endCursor: 'cursor2',
            },
          },
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityResponse(
        responseData,
        'test-project'
      );

      expect(result.content).toHaveLength(1);
      expect(result.content[0].type).toBe('text');

      const parsedContent = JSON.parse(result.content[0].text);
      expect(parsedContent.vulnerabilities).toHaveLength(1);
      expect(parsedContent.vulnerabilities[0].severity).toBe('CRITICAL');
      expect(parsedContent.vulnerabilities[0].package.name).toBe('vulnerable-package');
      expect(parsedContent.vulnerabilities[0].details.description).toBe(
        'This is a critical vulnerability'
      );
      expect(parsedContent.pagination_help).toBeDefined();
      expect(parsedContent.projectKey).toBe('test-project');
    });

    it('should handle empty vulnerabilities', () => {
      const emptyData = {
        repository: {
          dependencyVulnerabilities: {
            edges: [],
            pageInfo: {
              hasNextPage: false,
              hasPreviousPage: false,
              startCursor: null,
              endCursor: null,
            },
          },
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityResponse(
        emptyData,
        'test-project'
      );

      const parsedContent = JSON.parse(result.content[0].text);
      expect(parsedContent.vulnerabilities).toHaveLength(0);
      expect(parsedContent.totalCount).toBe(0);
    });
  });
});
