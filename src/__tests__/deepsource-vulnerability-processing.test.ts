import { DeepSourceClient } from '../deepsource';
import { jest } from '@jest/globals';

// Create a test subclass to expose private methods
class TestableDeepSourceClient extends DeepSourceClient {
  static testProcessVulnerabilityEdge(edge: unknown) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.processVulnerabilityEdge(edge);
  }

  static testIsValidVulnerabilityNode(node: unknown) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.isValidVulnerabilityNode(node);
  }

  static testMapVulnerabilityOccurrence(node: Record<string, unknown>) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.mapVulnerabilityOccurrence(node);
  }

  static testIterateVulnerabilities(edges: unknown[]) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.iterateVulnerabilities(edges);
  }

  // For setting up test scenarios
  static get MAX_ITERATIONS() {
    // @ts-expect-error - Accessing private property for testing
    return DeepSourceClient.MAX_ITERATIONS;
  }

  static set MAX_ITERATIONS(value: number) {
    // @ts-expect-error - Setting private property for testing
    DeepSourceClient.MAX_ITERATIONS = value;
  }
}

describe('DeepSource Vulnerability Processing', () => {
  describe('processVulnerabilityEdge', () => {
    it('should return null for null or undefined edge', () => {
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(null)).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(undefined)).toBeNull();
    });

    it('should return null for non-object edge', () => {
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge('string')).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(123)).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(true)).toBeNull();
    });

    it('should return null when node is missing', () => {
      const edge = { cursor: 'some-cursor' }; // Edge without node property
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(edge)).toBeNull();
    });

    it('should process valid vulnerability nodes', () => {
      // Mock isValidVulnerabilityNode and mapVulnerabilityOccurrence for this test
      const originalIsValid = TestableDeepSourceClient.testIsValidVulnerabilityNode;
      const originalMap = TestableDeepSourceClient.testMapVulnerabilityOccurrence;

      // Mock dependencies
      // @ts-expect-error - Mocking private static method
      DeepSourceClient.isValidVulnerabilityNode = jest.fn().mockReturnValue(true);
      // @ts-expect-error - Mocking private static method
      DeepSourceClient.mapVulnerabilityOccurrence = jest.fn().mockReturnValue({
        id: 'vuln-1',
        severity: 'HIGH',
        packageName: 'test-package',
      });

      const edge = {
        node: {
          id: 'vuln-node-1',
          severity: 'HIGH',
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityEdge(edge);

      expect(result).toEqual({
        id: 'vuln-1',
        severity: 'HIGH',
        packageName: 'test-package',
      });

      // Verify the mock was called with the node
      // @ts-expect-error - Accessing mocked method
      expect(DeepSourceClient.isValidVulnerabilityNode).toHaveBeenCalledWith(edge.node);
      // @ts-expect-error - Accessing mocked method
      expect(DeepSourceClient.mapVulnerabilityOccurrence).toHaveBeenCalledWith(edge.node);

      // Restore original methods after test
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.isValidVulnerabilityNode = originalIsValid;
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.mapVulnerabilityOccurrence = originalMap;
    });

    it('should return null for invalid vulnerability nodes', () => {
      // Mock isValidVulnerabilityNode to return false
      const originalIsValid = TestableDeepSourceClient.testIsValidVulnerabilityNode;

      // @ts-expect-error - Mocking private static method
      DeepSourceClient.isValidVulnerabilityNode = jest.fn().mockReturnValue(false);

      const edge = {
        node: {
          id: 'invalid-node',
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityEdge(edge);
      expect(result).toBeNull();

      // Restore original method after test
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.isValidVulnerabilityNode = originalIsValid;
    });
  });

  describe('iterateVulnerabilities', () => {
    // Mock the logger.warn to capture logs and prevent actual console output during tests
    let originalLogger: any;
    let mockWarn: jest.Mock;

    beforeEach(() => {
      // Save original logger
      // @ts-expect-error - Accessing private property
      originalLogger = DeepSourceClient.logger;

      // Create mock logger with warn function
      mockWarn = jest.fn();
      // @ts-expect-error - Setting private property
      DeepSourceClient.logger = {
        warn: mockWarn,
        debug: jest.fn(),
        info: jest.fn(),
        error: jest.fn(),
      };
    });

    afterEach(() => {
      // Restore original logger
      // @ts-expect-error - Restoring private property
      DeepSourceClient.logger = originalLogger;
    });

    it('should log a warning and return for non-array input', () => {
      // Test with non-array input (string)
      const nonArrayInput = 'not an array' as unknown as any[];
      const generator = TestableDeepSourceClient.testIterateVulnerabilities(nonArrayInput);

      // Convert generator to array to execute it
      const result = Array.from(generator);

      // Check that it logged a warning and returned empty array
      expect(result).toEqual([]);
      expect(mockWarn).toHaveBeenCalledWith(
        'Invalid edges data: expected an array but got',
        'string'
      );
    });

    it('should log a warning and break when exceeding max iterations', () => {
      // Save original MAX_ITERATIONS value
      const originalMaxIterations = TestableDeepSourceClient.MAX_ITERATIONS;

      try {
        // Set a very low MAX_ITERATIONS value for testing
        TestableDeepSourceClient.MAX_ITERATIONS = 1;

        // Create an array with more items than the max
        const edges = [
          { node: { id: 'vuln1' } },
          { node: { id: 'vuln2' } },
          { node: { id: 'vuln3' } }, // This might be skipped depending on the MAX_ITERATIONS check
        ];

        // Mock the processVulnerabilityEdge method to return valid vulnerabilities
        const originalProcessEdge = TestableDeepSourceClient.testProcessVulnerabilityEdge;

        // Create a spy to count how many times the method is called
        let callCount = 0;
        // @ts-expect-error - Mocking private method
        DeepSourceClient.processVulnerabilityEdge = jest.fn().mockImplementation((edge) => {
          callCount++;
          return { id: (edge as any).node.id, severity: 'HIGH' };
        });

        // Execute the generator and convert to array
        const generator = TestableDeepSourceClient.testIterateVulnerabilities(edges);
        const results = Array.from(generator);

        // Should log a warning about exceeding max iterations
        expect(mockWarn).toHaveBeenCalledWith(
          `Exceeded maximum iteration count (${TestableDeepSourceClient.MAX_ITERATIONS}). Stopping processing.`
        );

        // Verify the right number of calls were made before breaking
        expect(callCount).toBeLessThanOrEqual(TestableDeepSourceClient.MAX_ITERATIONS + 1);

        // Since MAX_ITERATIONS is set to 1, we can process up to 2 items
        // (One item at iteration 0, and one at iteration 1)
        expect(results.length).toBeLessThanOrEqual(TestableDeepSourceClient.MAX_ITERATIONS + 1);

        // Clean up
        // @ts-expect-error - Restoring private method
        DeepSourceClient.processVulnerabilityEdge = originalProcessEdge;
      } finally {
        // Restore original max iterations value
        TestableDeepSourceClient.MAX_ITERATIONS = originalMaxIterations;
      }
    });

    it('should handle errors during vulnerability processing', () => {
      // Mock processVulnerabilityEdge to throw an error for a specific edge
      const originalProcessEdge = TestableDeepSourceClient.testProcessVulnerabilityEdge;
      // @ts-expect-error - Mocking private method
      DeepSourceClient.processVulnerabilityEdge = jest.fn().mockImplementation((edge) => {
        if ((edge as any).node.id === 'error-edge') {
          throw new Error('Test processing error');
        }
        return { id: (edge as any).node.id, severity: 'HIGH' };
      });

      // Create test edges with one that will cause an error
      const edges = [
        { node: { id: 'vuln1' } },
        { node: { id: 'error-edge' } }, // This will cause an error
        { node: { id: 'vuln2' } },
      ];

      // Execute the generator and convert to array
      const generator = TestableDeepSourceClient.testIterateVulnerabilities(edges);
      const results = Array.from(generator);

      // Should skip the error edge and continue processing
      expect(results.length).toBe(2);
      expect(results[0].id).toBe('vuln1');
      expect(results[1].id).toBe('vuln2');

      // Should log a warning about the error
      expect(mockWarn).toHaveBeenCalledWith(
        'Error processing vulnerability edge:',
        expect.any(Error)
      );

      // Clean up
      // @ts-expect-error - Restoring private method
      DeepSourceClient.processVulnerabilityEdge = originalProcessEdge;
    });

    it('should skip null vulnerability results', () => {
      // Mock processVulnerabilityEdge to return null for specific edges
      const originalProcessEdge = TestableDeepSourceClient.testProcessVulnerabilityEdge;
      // @ts-expect-error - Mocking private method
      DeepSourceClient.processVulnerabilityEdge = jest.fn().mockImplementation((edge) => {
        if ((edge as any).node.id === 'invalid-edge') {
          return null;
        }
        return { id: (edge as any).node.id, severity: 'HIGH' };
      });

      // Create test edges with one that will return null
      const edges = [
        { node: { id: 'vuln1' } },
        { node: { id: 'invalid-edge' } }, // This will return null
        { node: { id: 'vuln2' } },
      ];

      // Execute the generator and convert to array
      const generator = TestableDeepSourceClient.testIterateVulnerabilities(edges);
      const results = Array.from(generator);

      // Should skip the null result and only return valid ones
      expect(results.length).toBe(2);
      expect(results[0].id).toBe('vuln1');
      expect(results[1].id).toBe('vuln2');

      // Clean up
      // @ts-expect-error - Restoring private method
      DeepSourceClient.processVulnerabilityEdge = originalProcessEdge;
    });
  });
});
