"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type Account implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """The unique identifier (or username) of the account."""
  login: String!

  """The account type (individual or team)."""
  type: AccountType!

  """VCS Provider of the account."""
  vcsProvider: VCSProvider!

  """Whether the account is a beta tester"""
  isBetaTester: Boolean!

  """URL for the account's public avatar."""
  avatarUrl: String

  """Get a report associated with this account"""
  report(
    """Get the report associated with the report key"""
    key: ReportKey!
  ): Report! @deprecated(reason: "Deprecated in favor of `reports`.")

  """Namespace containing all available reports."""
  reports: AccountReportsNamespace!

  """URL for the account on the VCS Provider."""
  vcsUrl: String

  """
  Get all repositories accessible to the current user under the given account.
  """
  repositories(offset: Int, before: String, after: String, first: Int, last: Int): RepositoryConnection!

  """Members of the team. This is an empty list for an individual account."""
  members(offset: Int, before: String, after: String, first: Int, last: Int): TeamMemberConnection!

  """Subscription and billing details of the account."""
  subscription: AccountSubscription!

  """Suppressed issues on the account/team."""
  suppressedIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueShortcode: String): TeamSuppressedIssueConnection!
}

type AccountConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Account` and its cursor."""
type AccountEdge {
  """The item at the end of the edge"""
  node: Account

  """A cursor for use in pagination"""
  cursor: String!
}

"""Namespace containing all the reports available for an `Account`"""
type AccountReportsNamespace {
  owaspTop10: OwaspTop10Report!
  sansTop25: SansTop25Report!
  misraC: MisraCReport!
  codeCoverage: CodeCoverageReport!
  codeHealthTrend: CodeHealthTrendReport!
  issueDistribution: IssueDistributionReport!
  issuesPrevented: IssuesPreventedReport!
  issuesAutofixed: IssuesAutofixedReport!
}

"""Subscription and billing details of an `Account`."""
type AccountSubscription {
  """The plan associated with this account's subscription."""
  plan: AccountSubscriptionPlan!
}

"""Represents DeepSource's subscription plans."""
enum AccountSubscriptionPlan {
  FREE
  STARTER
  BUSINESS
  ENTERPRISE
}

enum AccountType {
  """A individual account."""
  INDIVIDUAL

  """A team account."""
  TEAM
}

input ActivateRepositoryInput {
  """The repository's ID."""
  repositoryId: ID!
  clientMutationId: String
}

type ActivateRepositoryPayload {
  """Whether the repository has been activated successfully"""
  ok: Boolean!
  clientMutationId: String
}

type AnalysisRun implements MaskPrimaryKeyNode {
  createdAt: DateTime!
  branchName: String
  baseOid: String
  commitOid: String
  finishedAt: DateTime
  repository: Repository!

  """The ID of the object"""
  id: ID!

  """UID of this AnalysisRun."""
  runUid: UUID!

  """The current status of the run."""
  status: AnalysisRunStatus!

  """Summary of the analysis run"""
  summary: AnalysisRunSummary!

  """Time when the analysis run was last modified"""
  updatedAt: DateTime!

  """Analyzer checks in the analysis run."""
  checks(offset: Int, before: String, after: String, first: Int, last: Int, analyzerIn: [String]): CheckConnection

  """
  Statistics pertaining to the changeset (of a commit or PR) in the analysis run.
  """
  changesetStats: ChangesetStats
}

type AnalysisRunConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnalysisRunEdge]!
  totalCount: Int
}

"""A Relay edge containing a `AnalysisRun` and its cursor."""
type AnalysisRunEdge {
  """The item at the end of the edge"""
  node: AnalysisRun

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AnalysisRunStatus {
  PENDING
  SUCCESS
  FAILURE
  TIMEOUT
  CANCEL
  READY
  SKIPPED
}

type AnalysisRunSummary {
  """Number of issues introduced during this analysis run"""
  occurrencesIntroduced: Int

  """Number of issues marked as resolved in this analysis run"""
  occurrencesResolved: Int

  """Number of issues marked as suppressed in this analysis run"""
  occurrencesSuppressed: Int
  occurrenceDistributionByAnalyzer: [OccurrenceDistributionByAnalyzer]
  occurrenceDistributionByCategory: [OccurrenceDistributionByCategory]
}

"""A DeepSource Analyzer."""
type Analyzer implements MaskPrimaryKeyNode {
  """Version of the image used for this analyzer."""
  version: String!

  """Unique identifier for this analyzer globally."""
  shortcode: String!

  """Human-friendly name for this analyzer."""
  name: String!

  """Verbose description, written in Markdown."""
  description: String!

  """
  Schema of the meta fields accepted by the analyzer in .deepsource.toml.
  """
  metaSchema: JSONString!
  exampleConfig: String

  """The ID of the object"""
  id: ID!
  logo: String
  numIssues: Int
  issues(offset: Int, before: String, after: String, first: Int, last: Int): IssueConnection

  """Get a specific issue by its shortcode."""
  issue(
    """Shortcode of the issue."""
    shortcode: String!
  ): Issue
  issueDistribution: [IssueDistributionItem]
  type: AnalyzerType
}

type AnalyzerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnalyzerEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Analyzer` and its cursor."""
type AnalyzerEdge {
  """The item at the end of the edge"""
  node: Analyzer

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum AnalyzerType {
  CORE
  COMMUNITY
  CUSTOM
}

"""
Statistics pertaining to the changeset (of a commit or PR), as analyzed by an `AnalysisRun`.
"""
type ChangesetStats {
  """Stats for number of lines in the changeset."""
  lines: ChangesetStatsCounts!

  """Stats for number of branches in the changeset."""
  branches: ChangesetStatsCounts!

  """Stats for number of conditions in the changeset."""
  conditions: ChangesetStatsCounts!
}

"""
Overall and newly added number of lines (or branches or conditions) in a changeset.
"""
type ChangesetStatsCounts {
  """
  
          Overall number of lines (or branches or conditions) across the repository.
          Note: `0` depicts no lines (or branches or conditions) were found
  whereas `None` depicts the information is not available.
          
  """
  overall: Int

  """
  
          Overall number of lines (or branches or conditions) that are covered across the repository.",
          Note: `0` depicts no lines (or branches or conditions) were found
  whereas `None` depicts the information is not available.
          
  """
  overallCovered: Int

  """
  Newly added number of lines (or branches or conditions) in the changeset.
  Note: `0` depicts no lines (or branches or conditions) were found whereas `None` depicts the information is not available.
          
  """
  new: Int

  """
  
          Newly added number of lines (or branches or conditions) that are covered in the changeset.
          Note: `0` depicts no lines (or branches or conditions) were found
  whereas `None` depicts the information is not available.
          
  """
  newCovered: Int
}

"""A single analyzer check as part of an analysis run."""
type Check implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """Sequence number of the check in the analysis run it belongs to."""
  sequence: Int!

  """The current status of the check."""
  status: CheckStatus!

  """The analyzer related to the check."""
  analyzer: Analyzer!

  """Time when the check was created."""
  createdAt: DateTime!

  """Time when the check was last modified."""
  updatedAt: DateTime!

  """Time when the check finished."""
  finishedAt: DateTime

  """Summary of the check."""
  summary: CheckSummary!

  """Issue occurrences found in the check."""
  occurrences(offset: Int, before: String, after: String, first: Int, last: Int, analyzerIn: [String]): OccurrenceConnection!

  """List of DeepSource metrics captured in the check."""
  metrics: [RepositoryMetric!]
}

type CheckConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CheckEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Check` and its cursor."""
type CheckEdge {
  """The item at the end of the edge"""
  node: Check

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum CheckStatus {
  WAITING
  PENDING
  SUCCESS
  FAILURE
  TIMEOUT
  CANCEL
  READY
  NEUTRAL
  ARTIFACT_TIMEOUT
  SKIPPED
}

"""Summary of a check."""
type CheckSummary {
  """Number of issues introduced in the check."""
  occurrencesIntroduced: Int

  """Number of issues resolved in the check."""
  occurrencesResolved: Int

  """Number of issues marked as suppressed in the check."""
  occurrencesSuppressed: Int

  """The issue category distribution for the check."""
  occurrenceDistributionByCategory: [OccurrenceDistributionByCategory]
}

"""The Code Coverage report."""
type CodeCoverageReport {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The list of repositories."""
  repositories(
    """The query string to search for repositories."""
    q: String

    """The sort key to sort the repositories results by."""
    sortKey: CodeCoverageReportRepositorySortKey
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
  ): CodeCoverageReportRepositoryConnection
}

"""Representation of a `Repository` in the Code Coverage report."""
type CodeCoverageReportRepository implements MaskPrimaryKeyNode {
  """The name of this repository."""
  name: String!

  """The ID of the object"""
  id: ID!

  """The LCV metric value for this repository."""
  lcvMetricValue: Float

  """The BCV metric value for this repository."""
  bcvMetricValue: Float

  """Whether the LCV value is passing."""
  isLcvPassing: Boolean

  """Whether the BCV value is passing."""
  isBcvPassing: Boolean
}

type CodeCoverageReportRepositoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CodeCoverageReportRepositoryEdge]!
  totalCount: Int
}

"""
A Relay edge containing a `CodeCoverageReportRepository` and its cursor.
"""
type CodeCoverageReportRepositoryEdge {
  """The item at the end of the edge"""
  node: CodeCoverageReportRepository

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Possible options to sort the list of repositories in the Code Coverage report.
"""
enum CodeCoverageReportRepositorySortKey {
  LCV_ASCENDING
  LCV_DESCENDING
  BCV_ASCENDING
  BCV_DESCENDING
}

"""The Code Health Trend report."""
type CodeHealthTrendReport {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!
}

type ComplianceIssueOccurrenceCount {
  """The count of critical severity issues."""
  critical: Int

  """The count of major severity issues."""
  major: Int

  """The count of minor severity issues."""
  minor: Int

  """The total count of issues."""
  total: Int
}

type ComplianceIssueStat {
  """The key for this stat."""
  key: String

  """The title for this stat."""
  title: String

  """The occurrence count of the compliance issue."""
  occurrence: ComplianceIssueOccurrenceCount
}

type ComplianceReport implements Report {
  """The key of the report."""
  key: ReportKey

  """The title of the report."""
  title: String

  """The current value of the report."""
  currentValue: Int

  """The status of the report."""
  status: ReportStatus

  """The historical values for this report."""
  historicalValues(startDate: Date!, endDate: Date!): [HistoricalValueItem]

  """The trends associated with this report."""
  trends: [Trend]

  """The compliance issue stats associated with this report."""
  complianceIssueStats: [ComplianceIssueStat]
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

input DeactivateRepositoryInput {
  """The repository's ID."""
  repositoryId: ID!
  clientMutationId: String
}

type DeactivateRepositoryPayload {
  """Whether the repository has been deactivated successfully"""
  ok: Boolean!
  clientMutationId: String
}

"""The device type that is being registered."""
enum DeviceType {
  CLI
  IDE
}

"""Represents the direction of a value."""
enum Direction {
  UPWARD
  DOWNWARD
}

enum Ecosystem {
  NPM
  PYPI
  MAVEN
  GO
  RUBYGEMS
  NUGET
  PACKAGIST
  CRATES_IO
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

type HistoricalValue {
  """The key associated with the value."""
  key: String

  """The value."""
  value: Int
}

type HistoricalValueItem {
  """The date of the historical value."""
  date: Date

  """The values associated with this item."""
  values: [HistoricalValue]
}

"""Subscription details of an DeepSource IDE subscription."""
type IDESubscription {
  """The plan of this subscription."""
  plan: IDESubscriptionPlan!
}

"""Represents DeepSource's IDE subscription plans."""
enum IDESubscriptionPlan {
  FREE
  PRO
  SPONSORED
}

"""
An `IgnoreRule` defines the condition on which to suppress an `Issue`'s `Occurrence`s in a `Repository`.
"""
type IgnoreRule implements MaskPrimaryKeyNode {
  createdAt: DateTime!

  """The ID of the object"""
  id: ID!

  """Ignore level of the rule."""
  level: IgnoreRuleLevel!

  """Ignore type of the rule."""
  type: IgnoreRuleType!

  """The `Issue` to ignore in the rule."""
  issue: Issue!

  """File path if rule is on `FILE` level."""
  filePath: String

  """Glob pattern if rule is of `PATTERN` type."""
  globPattern: String
}

type IgnoreRuleConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [IgnoreRuleEdge]!
  totalCount: Int
}

"""A Relay edge containing a `IgnoreRule` and its cursor."""
type IgnoreRuleEdge {
  """The item at the end of the edge"""
  node: IgnoreRule

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Represents the level of an `IgnoreRule`.
- `REPOSITORY`: suppress the issue for all files in the repository.
- `FILE`: suppress the issue for the given file path in the repository.
"""
enum IgnoreRuleLevel {
  REPOSITORY
  FILE
}

"""
Represents the type of an `IgnoreRule`.
- `FOREVER`: suppress the issue in the repository always.
- `PATTERN`: suppress the issue occurrences matching the given glob pattern in the repository.
- `TEST_PATTERN`: suppress the issue occurrences matching the repository's specified test patterns in the repository.
"""
enum IgnoreRuleType {
  FOREVER
  PATTERN
  TEST_PATTERN
}

type InsightReport implements Report {
  """The key of the report."""
  key: ReportKey

  """The title of the report."""
  title: String

  """The current value of the report."""
  currentValue: Int

  """The status of the report."""
  status: ReportStatus

  """The historical values for this report."""
  historicalValues(startDate: Date!, endDate: Date!): [HistoricalValueItem]

  """The trends associated with this report."""
  trends: [Trend]
}

"""The DeepSource installation."""
type Installation implements MaskPrimaryKeyNode {
  """The name of the installation."""
  name: String!

  """The ID of the object"""
  id: ID!

  """The logo URL of the installation."""
  logo: String!
}

type Issue implements MaskPrimaryKeyNode {
  shortcode: String!
  title: String!
  analyzer: Analyzer!
  autofixAvailable: Boolean!
  isRecommended: Boolean!

  """The ID of the object"""
  id: ID!

  """Category of the issue."""
  category: IssueCategory!

  """Severity of the issue."""
  severity: IssueSeverity!

  """The description of the issue in markdown."""
  description: String!

  """A short description of the issue."""
  shortDescription: String!

  """A list of tags associated with the issue."""
  tags: [String]!
}

"""An enumeration."""
enum IssueCategory {
  ANTI_PATTERN
  BUG_RISK
  PERFORMANCE
  SECURITY
  COVERAGE
  TYPECHECK
  STYLE
  DOCUMENTATION
  SECRETS
}

"""
Configuration for an `IssueCategory` in a `Repository`. Also known as Quality Gates.
"""
type IssueCategorySetting {
  """An `IssueCategory`."""
  category: IssueCategory!

  """
  Whether issues of given category are enabled for reporting in the repository.
  """
  isReported: Boolean!

  """
  Whether to fail checks when occurrence(s) of issues of given category are found in the repository.
  """
  canFailCheck: Boolean!
}

type IssueConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [IssueEdge]!
  totalCount: Int
}

type IssueDistribution {
  key: String
  value: Int
}

type IssueDistributionItem {
  category: IssueCategory!
  title: String!
  count: Int!
}

type IssueDistributionReport implements Report {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The status of the report."""
  status: ReportStatus @deprecated(reason: "Report doesn't have a status.")

  """The historical values for this report."""
  historicalValues(startDate: Date!, endDate: Date!): [HistoricalValueItem] @deprecated(reason: "Deprecated in favor of `values`.")

  """The trends associated with this report."""
  trends: [Trend]!

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!
  issueDistributionByAnalyzer: [IssueDistribution]
  issueDistributionByCategory: [IssueDistribution]
}

"""A Relay edge containing a `Issue` and its cursor."""
type IssueEdge {
  """The item at the end of the edge"""
  node: Issue

  """A cursor for use in pagination"""
  cursor: String!
}

"""Configuration for an `IssuePriorityType` in a `Repository`."""
type IssuePrioritySetting {
  """A `IssuePriority`."""
  priorityType: IssuePriorityType!

  """
  Whether issues of given priority are enabled for reporting in the repository.
  """
  isReported: Boolean!

  """
  Whether to fail checks when occurrence(s) of issues of given priority are found in the repository.
  """
  canFailCheck: Boolean!
}

"""Enum for issue priority type."""
enum IssuePriorityType {
  LOW
  MEDIUM
  HIGH
}

"""The Issues Autofixed report."""
type IssuesAutofixedReport {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!
}

"""An enumeration."""
enum IssueSeverity {
  CRITICAL
  MAJOR
  MINOR
}

"""The Issues Prevented report."""
type IssuesPreventedReport {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!
}

"""A JSON object."""
scalar JSON

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""Custom node class to prevent leaking primary keys as integers"""
interface MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!
}

"""A metric tracked by an analyzer."""
type Metric implements MaskPrimaryKeyNode & MetricDefinition {
  """The ID of the object"""
  id: ID!

  """The metric's name."""
  name: String!

  """The metric's unique identifier."""
  shortcode: MetricShortcode!

  """The metric's description in markdown format."""
  description: String!

  """Direction which can be considered positive for the metric."""
  positiveDirection: Direction!

  """Unit suffix to apply to the metric value."""
  unit: String

  """Lower bound for the metric value."""
  minValueAllowed: Int

  """Upper bound for the metric value."""
  maxValueAllowed: Int
}

"""A metric's definition."""
interface MetricDefinition {
  """The metric's name."""
  name: String!

  """The metric's unique identifier."""
  shortcode: MetricShortcode!

  """The metric's description in markdown format."""
  description: String!

  """Direction which can be considered positive for the metric."""
  positiveDirection: Direction!

  """Unit suffix to apply to the metric value."""
  unit: String

  """Lower bound for the metric value."""
  minValueAllowed: Int

  """Upper bound for the metric value."""
  maxValueAllowed: Int
}

"""Represents the key for which the metric is recorded in a repository."""
enum MetricKey {
  AGGREGATE
  C_AND_CPP
  CSHARP
  GO
  JAVA
  JAVASCRIPT
  PHP
  PYTHON
  RUBY
  RUST
  SCALA
  KOTLIN
  SWIFT
}

"""
Configuration for a `Metric` in a `Repository`. Also known as Quality Gates.
"""
type MetricSetting {
  """The metric's unique identifier."""
  metricShortcode: MetricShortcode!

  """Whether the metric is enabled for reporting in the repository."""
  isReported: Boolean!

  """
  Whether to fail checks when the metric's thresholds are not met in the repository.
  """
  isThresholdEnforced: Boolean!
}

"""Represents the various metric types."""
enum MetricShortcode {
  BCV
  CCV
  DCV
  DDP
  LCV
  CPCV
  NLCV
  NBCV
  NCCV
  NCPCV
}

"""
Represents the status of the threshold condition for a particular metric value.
"""
enum MetricThresholdStatus {
  PASSING
  FAILING
}

"""An individual value captured for a RepositoryMetric."""
type MetricValue implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """Metric value reported by the analyzer."""
  value: Float!

  """Value suffixed with the unit of the metric."""
  valueDisplay: String!

  """
  Threshold value for the metric when this value was reported. Null if no threshold was set.
  """
  threshold: Int

  """The status of the threshold condition for the metric value."""
  thresholdStatus: MetricThresholdStatus

  """Commit SHA for which this value was recorded on the repository."""
  commitOid: String!

  """The time at which the value was captured."""
  createdAt: DateTime!
}

type MetricValueConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MetricValueEdge]!
  totalCount: Int
}

"""A Relay edge containing a `MetricValue` and its cursor."""
type MetricValueEdge {
  """The item at the end of the edge"""
  node: MetricValue

  """A cursor for use in pagination"""
  cursor: String!
}

"""The MISRA-C report."""
type MisraCReport {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!

  """The status of the report."""
  status: ReportStatus!

  """The compliance issue stats associated with this report."""
  securityIssueStats: [SecurityIssueStat]!
}

type Mutation {
  """
  Suppress an issue from an Analyzer on the team level, affecting all repositories.
  """
  suppressIssueForTeam(input: SuppressIssueForTeamInput!): SuppressIssueForTeamPayload

  """
  Remove a suppressed issue from an Analyzer on the team level, affecting all repositories.
  """
  unsuppressIssueForTeam(input: UnsuppressIssueForTeamInput!): UnsuppressIssueForTeamPayload

  """Update the threshold for a metric in a repository."""
  setRepositoryMetricThreshold(input: SetRepositoryMetricThresholdInput!): SetRepositoryMetricThresholdPayload

  """Regenerate a repository's DSN."""
  regenerateRepositoryDSN(input: RegenerateRepositoryDSNInput!): RegenerateRepositoryDSNPayload

  """
  Update a repository's default branch for baseline. If the repository is
  activated, this action will trigger a new analysis. Only available to users
  with `WRITE` permission on the repository.
  """
  updateRepositoryDefaultBranch(input: UpdateRepositoryDefaultBranchInput!): UpdateRepositoryDefaultBranchPayload

  """Update the configuration for an issue category in a repository."""
  updateRepositoryIssueCategorySetting(input: UpdateRepositoryIssueCategorySettingInput!): UpdateRepositoryIssueCategorySettingPayload

  """Update the configuration for an issue priority in a repository."""
  updateRepositoryIssuePrioritySetting(input: UpdateRepositoryIssuePrioritySettingInput!): UpdateRepositoryIssuePrioritySettingPayload

  """Update the configuration for a metric in a repository."""
  updateRepositoryMetricSetting(input: UpdateRepositoryMetricSettingInput!): UpdateRepositoryMetricSettingPayload

  """
  Activate a repository. Only available to users with `WRITE` permission on the repository.
  """
  activateRepository(input: ActivateRepositoryInput!): ActivateRepositoryPayload

  """
  Deactivate a repository. Only available to users with `WRITE` permission on the repository.
  """
  deactivateRepository(input: DeactivateRepositoryInput!): DeactivateRepositoryPayload
  revokeToken(refreshToken: String): Revoke
  verifyToken(token: String): Verify
  refreshToken(refreshToken: String): Refresh

  """
  Generates a unique device verification code and an end-user code that are
  valid for a limited time.
  """
  registerDevice(input: RegisterDeviceInput!): RegisterDevicePayload

  """
  Validates the device code provided and responds with the user's PAT.
  If there's no PAT associated with the user, create one. If the user
  has no access, return an error. Otherwise, indicate the client to keep
  polling.
  """
  requestPatWithDeviceCode(input: RequestPATWithDeviceCodeInput!): RequestPATWithDeviceCodePayload
  refreshPat: RefreshPAT
  revokePat: RevokePAT
}

type Occurrence implements MaskPrimaryKeyNode {
  path: String!
  beginLine: Int!
  beginColumn: Int!
  endLine: Int!
  endColumn: Int!

  """The ID of the object"""
  id: ID!

  """The definition of the issue which has been raised."""
  issue: Issue!

  """Title describing the issue which has been raised here."""
  title: String!
}

type OccurrenceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [OccurrenceEdge]!
  totalCount: Int
}

type OccurrenceDistributionByAnalyzer {
  """Shortcode of the analyzer"""
  analyzerShortcode: String!

  """Number of issues detected by the analyzer"""
  introduced: Int!
}

type OccurrenceDistributionByCategory {
  """Category of the issue"""
  category: IssueCategory!

  """Number of issues detected that belong to this category"""
  introduced: Int!
}

"""A Relay edge containing a `Occurrence` and its cursor."""
type OccurrenceEdge {
  """The item at the end of the edge"""
  node: Occurrence

  """A cursor for use in pagination"""
  cursor: String!
}

"""The OWASP Top 10 report."""
type OwaspTop10Report {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!

  """The status of the report."""
  status: ReportStatus!

  """The compliance issue stats associated with this report."""
  securityIssueStats: [SecurityIssueStat]!
}

type Package implements MaskPrimaryKeyNode {
  """The ecosystem of the package."""
  ecosystem: Ecosystem!

  """Name of the package"""
  name: String!

  """The package URL"""
  purl: String

  """The ID of the object"""
  id: ID!
}

"""

        Package managers supported by DeepSource
        
"""
enum PackageManager {
  REQUIREMENTS_TXT
  POETRY
  PIPFILE
  PDM
  NPM
  YARN
  PNPM
  GRADLE
  MAVEN
  GO_MOD
  RUBY_GEMS
  NUGET
  PACKAGIST
  CARGO
}

type PackageVersion implements MaskPrimaryKeyNode {
  """Version of the package"""
  version: String!

  """The type of the package version."""
  versionType: PackageVersionType

  """The ID of the object"""
  id: ID!
}

"""The type of the package version."""
enum PackageVersionType {
  SEMVER
  ECOSYSTEM
  GIT
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  """The currently authenticated user."""
  viewer: User

  """Lookup a transformer by it's shortcode."""
  transformer(
    """Shortcode of the transformer."""
    shortcode: String!
  ): Transformer

  """Lookup a transformer by it's shortcode."""
  transformers(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String): TransformerConnection

  """Lookup a repository on DeepSource using it's name and VCS provider."""
  repository(
    """The name of the repository to lookup."""
    name: String!

    """
    The login or username of the account under which the repository exists.
    """
    login: String!

    """VCS Provider of the repository."""
    vcsProvider: VCSProvider!
  ): Repository

  """The DeepSource installation."""
  installation: Installation

  """Get an analyzer from its shortcode."""
  analyzer(
    """Shortcode of the analyzer you'd like to get."""
    shortcode: String!
  ): Analyzer

  """Get all analyzers available on DeepSource."""
  analyzers(offset: Int, before: String, after: String, first: Int, last: Int): AnalyzerConnection

  """Fetch an AnalysisRun object from it's UID or commit OID."""
  run(
    """UID of the Analysis Run you want to get."""
    runUid: UUID

    """Commit OID of the Analysis Run you want to get."""
    commitOid: String
  ): AnalysisRun!

  """
  An account on DeepSource (individual or team). A user can add multiple accounts from multiple VCS providers.
  """
  account(
    """The login or username to lookup the account by."""
    login: String!

    """VCS Provider of the account."""
    vcsProvider: VCSProvider!
  ): Account
  node(
    """The ID of the object"""
    id: ID!
  ): MaskPrimaryKeyNode
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

type RefreshPAT {
  """The personal access token corresponding to the device_code"""
  token: String

  """Expiry of the token, in unix time"""
  expiry: DateTime
  user: User
}

input RegenerateRepositoryDSNInput {
  """GraphQL node ID of the repository."""
  repositoryId: ID!
  clientMutationId: String
}

type RegenerateRepositoryDSNPayload {
  """The new DSN for the repository."""
  dsn: String!
  clientMutationId: String
}

input RegisterDeviceInput {
  deviceType: DeviceType = CLI
  clientMutationId: String
}

"""
Generates a unique device verification code and an end-user code that are
valid for a limited time.
"""
type RegisterDevicePayload {
  """The device verification code."""
  deviceCode: String

  """The end-user verification code."""
  userCode: String

  """The end-user verification URI."""
  verificationUri: String

  """A verification URI that includes the 'user_code'."""
  verificationUriComplete: String

  """The lifetime in seconds of the 'device_code' and 'user_code'."""
  expiresIn: Int

  """
  The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.
  """
  interval: Int
  clientMutationId: String
}

interface Report {
  """The key of the report."""
  key: ReportKey

  """The title of the report."""
  title: String

  """The current value of the report."""
  currentValue: Int

  """The status of the report."""
  status: ReportStatus

  """The historical values for this report."""
  historicalValues(startDate: Date!, endDate: Date!): [HistoricalValueItem]

  """The trends associated with this report."""
  trends: [Trend]
}

"""All possible report keys."""
enum ReportKey {
  OWASP_TOP_10
  SANS_TOP_25
  MISRA_C
  CODE_COVERAGE
  CODE_HEALTH_TREND
  ISSUE_DISTRIBUTION
  ISSUES_PREVENTED
  ISSUES_AUTOFIXED
}

"""The different statuses possible for a report."""
enum ReportStatus {
  PASSING
  FAILING
  NOOP
}

"""Represents a value recorded for a report."""
type ReportValue {
  """The key associated with the value."""
  key: String!

  """The value."""
  value: Int!
}

"""Represents the values recorded on a specific date."""
type ReportValueItem {
  """The date when the values were recorded."""
  date: Date!

  """The values recorded on the given date."""
  values: [ReportValue]
}

type Repository implements MaskPrimaryKeyNode {
  """The name of this repository."""
  name: String!

  """Object ID of the latest commit on the default branch."""
  latestCommitOid: String
  isPrivate: Boolean!
  isActivated: Boolean!

  """The ID of the object"""
  id: ID!

  """The account under which this repository exists."""
  account: Account!

  """Past analysis runs for the repository"""
  analysisRuns(offset: Int, before: String, after: String, first: Int, last: Int): AnalysisRunConnection

  """
  The `.deepsource.toml` config of the repository represented as a JSON object.
  """
  configJson: JSON

  """The default base branch of the repository on DeepSource."""
  defaultBranch: String

  """The DSN for this repository."""
  dsn: String

  """Get all the analyzers enabled in this repository."""
  enabledAnalyzers(offset: Int, before: String, after: String, first: Int, last: Int): AnalyzerConnection

  """
  Get all issues raised in the default branch of this repository. Specifying a
  path would only return those issues whose occurrences are present in the file at path.
  """
  issues(
    """Show issues for this path only."""
    path: String
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    tags: [String]
    analyzerIn: [String]
  ): RepositoryIssueConnection

  """All issue occurrences in the default branch."""
  issueOccurrences(offset: Int, before: String, after: String, first: Int, last: Int, analyzerIn: [String]): OccurrenceConnection

  """List of dependency vulnerability occurrences in the default branch."""
  dependencyVulnerabilityOccurrences(offset: Int, before: String, after: String, first: Int, last: Int): VulnerabilityOccurrenceConnection

  """Get a dependency vulnerability occurrence by its ID."""
  dependencyVulnerabilityOccurrence(id: ID!): VulnerabilityOccurrence!

  """Get a specific repository target."""
  target(id: ID!): RepositoryTarget!

  """List of repository targets for this repository."""
  targets(offset: Int, before: String, after: String, first: Int, last: Int): RepositoryTargetConnection!

  """Get a report associated with this repository"""
  report(
    """Get the report associated with the report key"""
    key: ReportKey!
  ): Report! @deprecated(reason: "Deprecated in favor of `reports`.")

  """Namespace containing all available reports."""
  reports: RepositoryReportsNamespace!

  """VCS Provider of the repository."""
  vcsProvider: VCSProvider!

  """URL of the repository on the VCS."""
  vcsUrl: String!

  """List of all DeepSource metrics."""
  metrics(
    """List of metric shortcodes to filter on."""
    shortcodeIn: [MetricShortcode]
  ): [RepositoryMetric!]!

  """List of `IgnoreRule`s that exist for the repository."""
  ignoreRules(offset: Int, before: String, after: String, first: Int, last: Int, issueShortcode: String, filePath: String): IgnoreRuleConnection

  """Issue categories configuration for the repository."""
  issueCategorySettings: [IssueCategorySetting!]!

  """Issue priority configuration for the repository."""
  issuePrioritySettings: [IssuePrioritySetting!]!

  """Metric settings for the repository."""
  metricSettings: [MetricSetting!]!

  """
  Whether the account has allowed Autofix AI to run on private repositories.
  """
  allowAutofixAi: Boolean!
}

type RepositoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RepositoryEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Repository` and its cursor."""
type RepositoryEdge {
  """The item at the end of the edge"""
  node: Repository

  """A cursor for use in pagination"""
  cursor: String!
}

type RepositoryIssue implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """Definition of the issue that has been raised."""
  issue: Issue!

  """All occurrences of this issue in the default branch."""
  occurrences(offset: Int, before: String, after: String, first: Int, last: Int, analyzerIn: [String]): OccurrenceConnection

  """The repository for which this issue has been raised."""
  repository: Repository!
}

type RepositoryIssueConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RepositoryIssueEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RepositoryIssue` and its cursor."""
type RepositoryIssueEdge {
  """The item at the end of the edge"""
  node: RepositoryIssue

  """A cursor for use in pagination"""
  cursor: String!
}

"""A Metric's manifestation specific to a repository."""
type RepositoryMetric implements MetricDefinition {
  """The metric's name."""
  name: String!

  """The metric's unique identifier."""
  shortcode: MetricShortcode!

  """The metric's description in markdown format."""
  description: String!

  """Direction which can be considered positive for the metric."""
  positiveDirection: Direction!

  """Unit suffix to apply to the metric value."""
  unit: String

  """Lower bound for the metric value."""
  minValueAllowed: Int

  """Upper bound for the metric value."""
  maxValueAllowed: Int

  """Whether this metric is enabled for reporting in the repository."""
  isReported: Boolean!

  """
  Whether to fail checks when thresholds are not met for the metric in the repository.
  """
  isThresholdEnforced: Boolean!

  """Items in the repository metric."""
  items: [RepositoryMetricItem!]!
}

"""An item in the `RepositoryMetric`."""
type RepositoryMetricItem implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """Distinct key representing the metric in the repository."""
  key: MetricKey!

  """
  Threshold value for the metric, customizable by the user. Null if no threshold is set.
  """
  threshold: Int

  """
  Latest value captured for this metric on the repository's default branch.
  """
  latestValue: Float

  """
  Latest value captured for this metric on the repository's default branch.
  Suffixed with the unit and returned as a human-readable string.
  """
  latestValueDisplay: String

  """
  The status of the threshold condition for the latest metric value on the repository's default branch.
  """
  thresholdStatus: MetricThresholdStatus

  """
  All values captured for this metric in the repository's default branch.
  """
  values(offset: Int, before: String, after: String, first: Int, last: Int, commitOidIn: [String]): MetricValueConnection
}

"""Namespace containing all the reports available for an `Repository`"""
type RepositoryReportsNamespace {
  owaspTop10: OwaspTop10Report!
  sansTop25: SansTop25Report!
  misraC: MisraCReport!
  codeHealthTrend: CodeHealthTrendReport!
  issueDistribution: IssueDistributionReport!
  issuesPrevented: IssuesPreventedReport!
  issuesAutofixed: IssuesAutofixedReport!
}

"""A SCA target in a repository."""
type RepositoryTarget implements MaskPrimaryKeyNode {
  """The ecosystem of the target."""
  ecosystem: Ecosystem!

  """The package manager of the target."""
  packageManager: PackageManager!
  manifestPath: String
  lockfilePath: String!

  """The source of the target."""
  source: RepositoryTargetSource!
  isActivated: Boolean!

  """The ID of the object"""
  id: ID!
}

type RepositoryTargetConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [RepositoryTargetEdge]!
  totalCount: Int
}

"""A Relay edge containing a `RepositoryTarget` and its cursor."""
type RepositoryTargetEdge {
  """The item at the end of the edge"""
  node: RepositoryTarget

  """A cursor for use in pagination"""
  cursor: String!
}

"""

        The source of the target.
        
"""
enum RepositoryTargetSource {
  AUTO
  CUSTOM
}

input RequestPATWithDeviceCodeInput {
  deviceCode: String!
  description: String
  clientMutationId: String
}

"""
Validates the device code provided and responds with the user's PAT.
If there's no PAT associated with the user, create one. If the user
has no access, return an error. Otherwise, indicate the client to keep
polling.
"""
type RequestPATWithDeviceCodePayload {
  """The personal access token corresponding to the device_code"""
  token: String

  """Expiry of the token, in unix time"""
  expiry: DateTime
  user: User
  clientMutationId: String
}

type Revoke {
  revoked: Int!
}

type RevokePAT {
  """Indication whether revoking of personal access token was successful"""
  ok: Boolean
}

"""The SANS Top 25 report."""
type SansTop25Report {
  """The key of the report."""
  key: ReportKey!

  """The title of the report."""
  title: String!

  """The current value of the report."""
  currentValue: Int

  """The report values for this report."""
  values(
    """The start date to get the report values."""
    startDate: Date!

    """The start date to get the report values."""
    endDate: Date!
  ): [ReportValueItem]!

  """The trends associated with this report."""
  trends: [Trend]!

  """The status of the report."""
  status: ReportStatus!

  """The compliance issue stats associated with this report."""
  securityIssueStats: [SecurityIssueStat]!
}

type SecurityIssueStat {
  """The key for this stat."""
  key: String!

  """The title for this stat."""
  title: String!

  """The severity distribution for this stat."""
  occurrence: SeverityDistribution!
}

input SetRepositoryMetricThresholdInput {
  """GraphQL node ID of the repository."""
  repositoryId: ID!

  """Metric shortcode to update the threshold for."""
  metricShortcode: MetricShortcode!

  """The key of the metric you want to update the threshold for."""
  metricKey: MetricKey!

  """Threshold value to set. Can be null."""
  thresholdValue: Int
  clientMutationId: String
}

"""Update the threshold for a metric in a repository."""
type SetRepositoryMetricThresholdPayload {
  ok: Boolean
  clientMutationId: String
}

"""Distribution of severity count."""
type SeverityDistribution {
  """The count of critical severity issues."""
  critical: Int

  """The count of major severity issues."""
  major: Int

  """The count of minor severity issues."""
  minor: Int

  """The total count of issues."""
  total: Int
}

input SuppressIssueForTeamInput {
  """The issue's shortcode."""
  issueShortcode: String!

  """The login or username of the account/team."""
  login: String!

  """The VCS provider of the account/team."""
  vcsProvider: VCSProvider!
  clientMutationId: String
}

"""
Suppress an issue from an Analyzer on the team level, affecting all repositories.
"""
type SuppressIssueForTeamPayload {
  ok: Boolean
  clientMutationId: String
}

"""Represents a user within a team."""
type TeamMember implements MaskPrimaryKeyNode {
  """The ID of the object"""
  id: ID!

  """The User instance."""
  user: User!

  """The role this user has in the team."""
  role: TeamMemberRole!

  """Whether this user is the owner of the team."""
  isOwner: Boolean!

  """The time when this user joined the team."""
  joinedAt: DateTime!
}

type TeamMemberConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TeamMemberEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TeamMember` and its cursor."""
type TeamMemberEdge {
  """The item at the end of the edge"""
  node: TeamMember

  """A cursor for use in pagination"""
  cursor: String!
}

"""An enumeration."""
enum TeamMemberRole {
  ADMIN
  MEMBER
  CONTRIBUTOR
}

"""
A `TeamSuppressedIssue` represents an issue from an analyzer that has been suppressed on the team level. This is
a global suppression that affects all repositories in the team.
"""
type TeamSuppressedIssue implements MaskPrimaryKeyNode {
  createdAt: DateTime!

  """The ID of the object"""
  id: ID!

  """The `Issue` that is suppressed."""
  issue: Issue!

  """The user who suppressed the issue."""
  user: User
}

type TeamSuppressedIssueConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TeamSuppressedIssueEdge]!
  totalCount: Int
}

"""A Relay edge containing a `TeamSuppressedIssue` and its cursor."""
type TeamSuppressedIssueEdge {
  """The item at the end of the edge"""
  node: TeamSuppressedIssue

  """A cursor for use in pagination"""
  cursor: String!
}

"""A transformer on DeepSource."""
type Transformer implements MaskPrimaryKeyNode {
  analyzer: Analyzer
  exampleConfig: String

  """Name of the tool."""
  name: String!

  """Unique identifier for this tool globally."""
  shortcode: String!

  """Verbose description, written in Markdown."""
  description: String!

  """The ID of the object"""
  id: ID!
  logo: String
}

type TransformerConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TransformerEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Transformer` and its cursor."""
type TransformerEdge {
  """The item at the end of the edge"""
  node: Transformer

  """A cursor for use in pagination"""
  cursor: String!
}

"""Represents a trend for a report."""
type Trend {
  """The label associated with the trend."""
  label: String

  """The value of the trend."""
  value: Int

  """The percentage change in the trend."""
  rate: Float @deprecated(reason: "Deprecated in favor of `changePercentage`.")

  """The percentage change in the trend."""
  changePercentage: Float
}

input UnsuppressIssueForTeamInput {
  """The issue's shortcode."""
  issueShortcode: String!

  """The login or username of the account/team."""
  login: String!

  """The VCS provider of the account/team."""
  vcsProvider: VCSProvider!
  clientMutationId: String
}

"""
Remove a suppressed issue from an Analyzer on the team level, affecting all repositories.
"""
type UnsuppressIssueForTeamPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateRepositoryDefaultBranchInput {
  """GraphQL node ID of the repository."""
  id: ID!

  """Default branch for analysis on the repository."""
  defaultBranchName: String!
  clientMutationId: String
}

type UpdateRepositoryDefaultBranchPayload {
  ok: Boolean!
  repository: Repository!
  clientMutationId: String
}

input UpdateRepositoryIssueCategorySettingInput {
  """The repository's ID."""
  repositoryId: ID!

  """The issue category you want to update."""
  issueCategory: IssueCategory!

  """
  Whether issues of given category are enabled for reporting in the repository.
  """
  isReported: Boolean!

  """
  Whether to fail checks when occurrence(s) of issues of given category are
  found in the repository. An issue category can only be marked to fail a check
  if it is enabled for reporting.
  """
  canFailCheck: Boolean!
  clientMutationId: String
}

type UpdateRepositoryIssueCategorySettingPayload {
  ok: Boolean!
  clientMutationId: String
}

input UpdateRepositoryIssuePrioritySettingInput {
  """The repository's ID."""
  repositoryId: ID!

  """The issue priority you want to update."""
  issuePriorityType: IssuePriorityType!

  """
  Whether issues of given priority are enabled for reporting in the repository.
  """
  isReported: Boolean!

  """
  Whether to fail checks when occurrence(s) of issues of given priority are found in the repository.
  """
  canFailCheck: Boolean!
  clientMutationId: String
}

type UpdateRepositoryIssuePrioritySettingPayload {
  ok: Boolean!
  clientMutationId: String
}

input UpdateRepositoryMetricSettingInput {
  """The repository's ID."""
  repositoryId: ID!

  """The metric to update."""
  metricShortcode: MetricShortcode!

  """Whether the metric is enabled for reporting in the repository."""
  isReported: Boolean!

  """Whether to fail checks when the metric does not meet the threshold."""
  isThresholdEnforced: Boolean!
  clientMutationId: String
}

type UpdateRepositoryMetricSettingPayload {
  ok: Boolean!
  clientMutationId: String
}

type User implements MaskPrimaryKeyNode {
  firstName: String!
  lastName: String!
  email: String!

  """The ID of the object"""
  id: ID!

  """
  All the accounts associated with the user. This includes the team accounts the
  user is part of and the individual accounts they have added on DeepSource.
  """
  accounts(offset: Int, before: String, after: String, first: Int, last: Int): AccountConnection

  """The anonymous ID used for analytics and tracking."""
  analyticsId: String!

  """Whether the user is a beta tester."""
  isBetaTester: Boolean!

  """The IDE subscription associated with the user."""
  ideSubscription: IDESubscription
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""An enumeration."""
enum VCSProvider {
  GITHUB
  GITLAB
  BITBUCKET
  BITBUCKET_DATACENTER
  GITHUB_ENTERPRISE
  GSR
  ADS
}

type Verify {
  payload: GenericScalar!
}

type Vulnerability implements MaskPrimaryKeyNode {
  """CVSS v2 vector"""
  cvssV2Vector: String

  """CVSS v2 base score"""
  cvssV2BaseScore: Float

  """Severity based on the CVSSv2 base score."""
  cvssV2Severity: VulnerabilitySeverity

  """CVSS v3 vector"""
  cvssV3Vector: String

  """CVSS v3 base score"""
  cvssV3BaseScore: Float

  """Severity based on the CVSSv3 base score."""
  cvssV3Severity: VulnerabilitySeverity

  """CVSS v4 vector"""
  cvssV4Vector: String

  """CVSS v4 base score"""
  cvssV4BaseScore: Float

  """Severity based on the CVSSv4 base score."""
  cvssV4Severity: VulnerabilitySeverity

  """Overall implied severity."""
  severity: VulnerabilitySeverity

  """The identifier of the vulnerability"""
  identifier: String!

  """The aliases of the vulnerability"""
  aliases: [String!]!

  """The summary of the vulnerability"""
  summary: String

  """The details of the vulnerability"""
  details: String

  """The time when the vulnerability was published"""
  publishedAt: DateTime!

  """The time when the vulnerability was updated"""
  updatedAt: DateTime!

  """The time when the vulnerability was withdrawn"""
  withdrawnAt: DateTime

  """The EPSS score of the vulnerability"""
  epssScore: Float

  """The EPSS percentile of the vulnerability"""
  epssPercentile: Float

  """Introduced versions."""
  introducedVersions: [String]!

  """Fixed versions."""
  fixedVersions: [String]!

  """The ID of the object"""
  id: ID!

  """Reference URLs."""
  referenceUrls: [String]!
}

type VulnerabilityOccurrence implements MaskPrimaryKeyNode {
  """The reachability of the vulnerability occurrence."""
  reachability: VulnerabilityOccurrenceReachability!

  """The fixability of the vulnerability occurrence."""
  fixability: VulnerabilityOccurrenceFixability!

  """The vulnerability."""
  vulnerability: Vulnerability!

  """The ID of the object"""
  id: ID!

  """The package associated with the vulnerability occurrence."""
  package: Package!

  """The package version associated with the vulnerability occurrence."""
  packageVersion: PackageVersion!
}

type VulnerabilityOccurrenceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [VulnerabilityOccurrenceEdge]!
  totalCount: Int
}

"""A Relay edge containing a `VulnerabilityOccurrence` and its cursor."""
type VulnerabilityOccurrenceEdge {
  """The item at the end of the edge"""
  node: VulnerabilityOccurrence

  """A cursor for use in pagination"""
  cursor: String!
}

"""

        The fixability type of the vulnerability occurrence
        
"""
enum VulnerabilityOccurrenceFixability {
  ERROR
  UNFIXABLE
  GENERATING_FIX
  POSSIBLY_FIXABLE
  MANUALLY_FIXABLE
  AUTO_FIXABLE
}

"""

        The reachability type of the vulnerability occurrence
        
"""
enum VulnerabilityOccurrenceReachability {
  REACHABLE
  UNREACHABLE
  UNKNOWN
}

"""The severity of the vulnerability."""
enum VulnerabilitySeverity {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

