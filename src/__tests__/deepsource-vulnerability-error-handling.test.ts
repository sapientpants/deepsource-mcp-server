/**
 * Tests for DeepSource vulnerability error handling
 * This file specifically targets error handling in the vulnerability functionality
 * including line 1975 which uses handleGraphQLError as fallback
 */
import { jest, expect } from '@jest/globals';
import nock from 'nock';
import { DeepSourceClient } from '../deepsource.js';
import { ErrorCategory } from '../utils/errors.js';
import { getPrivateMethod } from './test-utils/private-method-access.js';

describe('DeepSourceClient Vulnerability Error Handling', () => {
  // Test variables
  const API_KEY = 'test-api-key';
  let client: DeepSourceClient;

  // Setup client and mock environment
  beforeEach(() => {
    client = new DeepSourceClient(API_KEY);
    nock.disableNetConnect();
  });

  // Clean up after each test
  afterEach(() => {
    nock.cleanAll();
    nock.enableNetConnect();
    jest.clearAllMocks();
  });

  describe('handleVulnerabilityError', () => {
    // Get access to the private static method
    const handleVulnerabilityError = getPrivateMethod<(_error: Error, _projectKey: string) => void>(
      'handleVulnerabilityError'
    );

    it('should throw specific errors based on error category', () => {
      // Setup error handling behavior

      // Replace the original function with our mock
      jest.spyOn(DeepSourceClient as any, 'isErrorWithMessage').mockImplementation(() => false);

      // Test cases for different error messages
      const testCases = [
        // Authentication errors
        {
          message: 'Authentication failed',
          expectedCategory: ErrorCategory.AUTH,
        },
        // Not found errors
        {
          message: 'Repository not found',
          expectedCategory: ErrorCategory.NOT_FOUND,
        },
        // Server errors
        {
          message: 'Internal server error',
          expectedCategory: ErrorCategory.SERVER,
        },
        // Any other error
        {
          message: 'Unknown error',
          expectedCategory: ErrorCategory.OTHER,
        },
      ];

      for (const testCase of testCases) {
        const error = new Error(testCase.message);

        // This will throw an error, which we expect
        expect(() => {
          handleVulnerabilityError(error, 'test-project');
        }).toThrow();
      }
    });
  });

  describe('getDependencyVulnerabilities error handling', () => {
    beforeEach(() => {
      // Mock necessary private methods for testing
      jest.spyOn(DeepSourceClient, 'validateProjectKey' as any).mockImplementation(() => {});
      jest.spyOn(DeepSourceClient, 'validateProjectRepository' as any).mockImplementation(() => {});
      jest.spyOn(DeepSourceClient, 'buildVulnerabilityQuery' as any).mockReturnValue('test-query');
      jest.spyOn(DeepSourceClient, 'processVulnerabilityResponse' as any).mockReturnValue({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null,
        },
        totalCount: 0,
      });
      jest.spyOn(DeepSourceClient, 'normalizePaginationParams' as any).mockReturnValue({
        first: 10,
        offset: 0,
      });
      jest
        .spyOn(DeepSourceClient, 'extractErrorMessages' as any)
        .mockImplementation((errors) =>
          errors.map((e: { message: string }) => e.message).join(', ')
        );

      // Mock the client's listProjects method
      jest.spyOn(client, 'listProjects').mockResolvedValue([
        {
          key: 'test-project',
          name: 'Test Project',
          repository: {
            url: 'https://github.com/org/test-project',
            provider: 'GITHUB',
            login: 'org',
            isPrivate: false,
            isActivated: true,
          },
        },
      ]);
    });

    // Test NoneType errors (line 1958-1967)
    it('should handle NoneType errors by returning empty results', async () => {
      // Mock isError and isErrorWithMessage methods
      jest.spyOn(DeepSourceClient, 'isError' as any).mockReturnValue(true);
      jest
        .spyOn(DeepSourceClient, 'isErrorWithMessage' as any)
        .mockImplementation((_error, message) => message === 'NoneType');

      // Mock API call to throw an error
      const mockError = new Error("'NoneType' object has no attribute 'vulnerabilityOccurrences'");
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method
      const result = await client.getDependencyVulnerabilities('test-project', {});

      // Verify empty results are returned
      expect(result).toEqual({
        items: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    // Test specific error handling (line 1971)
    it('should call handleVulnerabilityError for specific errors', async () => {
      // Spy on handleVulnerabilityError
      const handleVulnerabilityErrorSpy = jest
        .spyOn(DeepSourceClient as any, 'handleVulnerabilityError')
        .mockImplementation(() => {
          throw new Error('Handled by handleVulnerabilityError');
        });

      // Mock isError but not isErrorWithMessage
      jest.spyOn(DeepSourceClient, 'isError' as any).mockReturnValue(true);
      jest.spyOn(DeepSourceClient, 'isErrorWithMessage' as any).mockReturnValue(false);

      // Mock API call to throw an error
      const mockError = new Error('Repository not found');
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method and expect it to throw
      await expect(client.getDependencyVulnerabilities('test-project', {})).rejects.toThrow(
        'Handled by handleVulnerabilityError'
      );

      // Verify handleVulnerabilityError was called
      expect(handleVulnerabilityErrorSpy).toHaveBeenCalledWith(mockError, 'test-project');
    });

    // Test fallback to handleGraphQLError (line 1975)
    it('should fall back to handleGraphQLError when isError returns false', async () => {
      // Spy on handleGraphQLError
      const handleGraphQLErrorSpy = jest
        .spyOn(DeepSourceClient as any, 'handleGraphQLError')
        .mockReturnValue({
          items: [],
          pageInfo: {
            hasNextPage: false,
            hasPreviousPage: false,
          },
          totalCount: 0,
        });

      // Mock isError to return false to trigger the fallback path
      jest.spyOn(DeepSourceClient, 'isError' as any).mockReturnValue(false);

      // Mock API call to throw an error
      const mockError = new Error('Generic error');
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method
      await client.getDependencyVulnerabilities('test-project', {});

      // Verify handleGraphQLError was called - this tests line 1975
      expect(handleGraphQLErrorSpy).toHaveBeenCalledWith(mockError);
    });

    // Test for errors when constructing response
    it('should handle errors in the construction phase', async () => {
      // Mock successful API response that will trigger later errors
      jest.spyOn(client['client'], 'post').mockResolvedValue({
        data: {
          data: {
            repository: null, // This will cause errors in processVulnerabilityResponse
          },
        },
      });

      // Mock a specific error in the processing phase
      jest.spyOn(DeepSourceClient, 'processVulnerabilityResponse' as any).mockImplementation(() => {
        throw new Error('Error processing response');
      });

      // Mock error handling
      const handleGraphQLErrorSpy = jest
        .spyOn(DeepSourceClient as any, 'handleGraphQLError')
        .mockReturnValue({
          items: [],
          pageInfo: {
            hasNextPage: false,
            hasPreviousPage: false,
          },
          totalCount: 0,
        });

      // Call the method
      await client.getDependencyVulnerabilities('test-project', {});

      // Verify handleGraphQLError was called - this tests line 1975 indirectly
      expect(handleGraphQLErrorSpy).toHaveBeenCalled();
    });

    // Test successful retrieval
    it('should retrieve vulnerabilities successfully', async () => {
      // Mock successful response
      jest.spyOn(client['client'], 'post').mockResolvedValue({
        data: {
          data: {
            repository: {
              vulnerabilityOccurrences: {
                edges: [],
                pageInfo: {
                  hasNextPage: false,
                  hasPreviousPage: false,
                  startCursor: null,
                  endCursor: null,
                },
                totalCount: 0,
              },
            },
          },
        },
      });

      const result = await client.getDependencyVulnerabilities('test-project', {});

      // Verify successful processing
      expect(result).toEqual({
        items: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null,
        },
        totalCount: 0,
      });
    });
  });
});
