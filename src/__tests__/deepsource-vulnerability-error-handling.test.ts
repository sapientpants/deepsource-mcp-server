/**
 * Tests for DeepSource vulnerability error handling
 * This file specifically targets error handling in the vulnerability functionality
 * including line 1975 which uses handleGraphQLError as fallback
 */
import { jest, expect } from '@jest/globals';
import nock from 'nock';
import { DeepSourceClient } from '../deepsource.js';
import { ErrorCategory } from '../utils/errors.js';
import { getPrivateMethod } from './test-utils/private-method-access.js';

describe('DeepSourceClient Vulnerability Error Handling', () => {
  // Test variables
  const API_KEY = 'test-api-key';
  let client: DeepSourceClient;

  // Setup client and mock environment
  beforeEach(() => {
    client = new DeepSourceClient(API_KEY);
    nock.disableNetConnect();
  });

  // Clean up after each test
  afterEach(() => {
    nock.cleanAll();
    nock.enableNetConnect();
    jest.clearAllMocks();
  });

  describe('handleVulnerabilityError', () => {
    // Get access to the private static method
    const handleVulnerabilityError = getPrivateMethod<(_error: Error, _projectKey: string) => void>(
      'handleVulnerabilityError'
    );

    it('should throw specific errors based on error category', () => {
      // Setup error handling behavior

      // Replace the original function with our mock
      type ClientMethods = {
        isErrorWithMessage: (_error: unknown) => boolean;
      };
      jest
        .spyOn(DeepSourceClient as unknown as ClientMethods, 'isErrorWithMessage')
        .mockImplementation(() => false);

      // Test cases for different error messages
      const testCases = [
        // Authentication errors
        {
          message: 'Authentication failed',
          expectedCategory: ErrorCategory.AUTH,
        },
        // Not found errors
        {
          message: 'Repository not found',
          expectedCategory: ErrorCategory.NOT_FOUND,
        },
        // Server errors
        {
          message: 'Internal server error',
          expectedCategory: ErrorCategory.SERVER,
        },
        // Any other error
        {
          message: 'Unknown error',
          expectedCategory: ErrorCategory.OTHER,
        },
      ];

      for (const testCase of testCases) {
        const error = new Error(testCase.message);

        // This will throw an error, which we expect
        expect(() => {
          handleVulnerabilityError(error, 'test-project');
        }).toThrow();
      }
    });
  });

  describe('getDependencyVulnerabilities error handling', () => {
    // Define interfaces for private methods at describe level
    interface PrivateMethods {
      validateProjectKey: (_key: string) => void;
      validateProjectRepository: (_repo: unknown) => void;
      buildVulnerabilityQuery: (_params: unknown) => string;
      processVulnerabilityResponse: (_response: unknown) => {
        vulnerabilities: unknown[];
        pageInfo: unknown;
        totalCount: number;
      };
    }

    interface MorePrivateMethods {
      normalizePaginationParams: (_params: unknown) => { first: number; offset: number };
      extractErrorMessages: (_errors: Array<{ message: string }>) => string;
    }

    interface ErrorHandlingMethods {
      isError: (_error: unknown) => boolean;
      isErrorWithMessage: (_error: unknown, _message: string) => boolean;
    }

    // Create typed references
    const clientPrivate = DeepSourceClient as unknown as PrivateMethods;
    const morePrivate = DeepSourceClient as unknown as MorePrivateMethods;
    const errorHandling = DeepSourceClient as unknown as ErrorHandlingMethods;

    beforeEach(() => {
      // Mock necessary private methods for testing
      jest.spyOn(clientPrivate, 'validateProjectKey').mockImplementation(() => {});
      jest.spyOn(clientPrivate, 'validateProjectRepository').mockImplementation(() => {});
      jest.spyOn(clientPrivate, 'buildVulnerabilityQuery').mockReturnValue('test-query');
      jest.spyOn(clientPrivate, 'processVulnerabilityResponse').mockReturnValue({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null,
        },
        totalCount: 0,
      });
      jest.spyOn(morePrivate, 'normalizePaginationParams').mockReturnValue({
        first: 10,
        offset: 0,
      });
      jest
        .spyOn(morePrivate, 'extractErrorMessages')
        .mockImplementation((errors) =>
          errors.map((e: { message: string }) => e.message).join(', ')
        );

      // Mock the client's listProjects method
      jest.spyOn(client, 'listProjects').mockResolvedValue([
        {
          key: 'test-project',
          name: 'Test Project',
          repository: {
            url: 'https://github.com/org/test-project',
            provider: 'GITHUB',
            login: 'org',
            isPrivate: false,
            isActivated: true,
          },
        },
      ]);
    });

    // Test NoneType errors (line 1958-1967)
    it('should handle NoneType errors by returning empty results', async () => {
      // Mock isError and isErrorWithMessage methods
      jest.spyOn(errorHandling, 'isError').mockReturnValue(true);
      jest
        .spyOn(errorHandling, 'isErrorWithMessage')
        .mockImplementation((_error, message) => message === 'NoneType');

      // Mock API call to throw an error
      const mockError = new Error("'NoneType' object has no attribute 'vulnerabilityOccurrences'");
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method
      const result = await client.getDependencyVulnerabilities('test-project', {});

      // Verify empty results are returned
      expect(result).toEqual({
        items: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    // Test specific error handling (line 1971)
    it('should call handleVulnerabilityError for specific errors', async () => {
      // Spy on the private static method with proper type casting
      const handleVulnerabilityErrorSpy = jest
        .spyOn(
          DeepSourceClient as unknown as { handleVulnerabilityError: (_error: unknown) => void },
          'handleVulnerabilityError'
        )
        .mockImplementation(() => {
          throw new Error('Handled by handleVulnerabilityError');
        });

      // Mock isError but not isErrorWithMessage
      jest.spyOn(errorHandling, 'isError').mockReturnValue(true);
      jest.spyOn(errorHandling, 'isErrorWithMessage').mockReturnValue(false);

      // Mock API call to throw an error
      const mockError = new Error('Repository not found');
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method and expect it to throw
      await expect(client.getDependencyVulnerabilities('test-project', {})).rejects.toThrow(
        'Handled by handleVulnerabilityError'
      );

      // Verify handleVulnerabilityError was called
      expect(handleVulnerabilityErrorSpy).toHaveBeenCalledWith(mockError, 'test-project');
    });

    // Test fallback to handleGraphQLError (line 1975)
    it('should fall back to handleGraphQLError when isError returns false', async () => {
      // Spy on handleGraphQLError
      interface GraphQLErrorHandler {
        handleGraphQLError: (_error: unknown) => {
          items: unknown[];
          pageInfo: unknown;
          totalCount: number;
        };
      }
      const handleGraphQLErrorSpy = jest
        .spyOn(DeepSourceClient as unknown as GraphQLErrorHandler, 'handleGraphQLError')
        .mockReturnValue({
          items: [],
          pageInfo: {
            hasNextPage: false,
            hasPreviousPage: false,
          },
          totalCount: 0,
        });

      // Mock isError to return false to trigger the fallback path
      jest.spyOn(errorHandling, 'isError').mockReturnValue(false);

      // Mock API call to throw an error
      const mockError = new Error('Generic error');
      jest.spyOn(client['client'], 'post').mockRejectedValue(mockError);

      // Call the method
      await client.getDependencyVulnerabilities('test-project', {});

      // Verify handleGraphQLError was called - this tests line 1975
      expect(handleGraphQLErrorSpy).toHaveBeenCalledWith(mockError);
    });

    // Test for errors when constructing response
    it('should handle errors in the construction phase', async () => {
      // Mock successful API response that will trigger later errors
      jest.spyOn(client['client'], 'post').mockResolvedValue({
        data: {
          data: {
            repository: null, // This will cause errors in processVulnerabilityResponse
          },
        },
      });

      // Mock a specific error in the processing phase
      jest.spyOn(clientPrivate, 'processVulnerabilityResponse').mockImplementation(() => {
        throw new Error('Error processing response');
      });

      // Mock error handling
      interface GraphQLErrorHandler {
        handleGraphQLError: (_error: unknown) => {
          items: unknown[];
          pageInfo: unknown;
          totalCount: number;
        };
      }
      const handleGraphQLErrorSpy = jest
        .spyOn(DeepSourceClient as unknown as GraphQLErrorHandler, 'handleGraphQLError')
        .mockReturnValue({
          items: [],
          pageInfo: {
            hasNextPage: false,
            hasPreviousPage: false,
          },
          totalCount: 0,
        });

      // Call the method
      await client.getDependencyVulnerabilities('test-project', {});

      // Verify handleGraphQLError was called - this tests line 1975 indirectly
      expect(handleGraphQLErrorSpy).toHaveBeenCalled();
    });

    // Test successful retrieval
    it('should retrieve vulnerabilities successfully', async () => {
      // Mock successful response
      jest.spyOn(client['client'], 'post').mockResolvedValue({
        data: {
          data: {
            repository: {
              vulnerabilityOccurrences: {
                edges: [],
                pageInfo: {
                  hasNextPage: false,
                  hasPreviousPage: false,
                  startCursor: null,
                  endCursor: null,
                },
                totalCount: 0,
              },
            },
          },
        },
      });

      const result = await client.getDependencyVulnerabilities('test-project', {});

      // Verify successful processing
      expect(result).toEqual({
        items: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null,
        },
        totalCount: 0,
      });
    });
  });
});
