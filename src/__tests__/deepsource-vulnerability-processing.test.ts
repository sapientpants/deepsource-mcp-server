import { DeepSourceClient } from '../deepsource';
import { jest } from '@jest/globals';

// Create a test subclass to expose private methods
class TestableDeepSourceClient extends DeepSourceClient {
  static testProcessVulnerabilityEdge(edge: unknown) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.processVulnerabilityEdge(edge);
  }

  static testIsValidVulnerabilityNode(node: unknown) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.isValidVulnerabilityNode(node);
  }

  static testMapVulnerabilityOccurrence(node: Record<string, unknown>) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.mapVulnerabilityOccurrence(node);
  }

  static testIterateVulnerabilities(edges: unknown[]) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.iterateVulnerabilities(edges);
  }

  static testProcessVulnerabilityResponse(response: unknown) {
    // @ts-expect-error - Accessing private method for testing
    return DeepSourceClient.processVulnerabilityResponse(response);
  }

  // For setting up test scenarios
  static get MAX_ITERATIONS() {
    // @ts-expect-error - Accessing private property for testing
    return DeepSourceClient.MAX_ITERATIONS;
  }

  static set MAX_ITERATIONS(value: number) {
    // @ts-expect-error - Setting private property for testing
    DeepSourceClient.MAX_ITERATIONS = value;
  }
}

describe('DeepSource Vulnerability Processing', () => {
  describe('processVulnerabilityResponse', () => {
    it('should handle null or non-object response', () => {
      // Test with null response
      const nullResult = TestableDeepSourceClient.testProcessVulnerabilityResponse(null);
      expect(nullResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });

      // Test with non-object response
      const stringResult = TestableDeepSourceClient.testProcessVulnerabilityResponse('string');
      expect(stringResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    it('should handle missing or invalid data field', () => {
      // Response with missing data field
      const missingDataResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({});
      expect(missingDataResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });

      // Response with non-object data field
      const invalidDataResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: 'not an object',
      });
      expect(invalidDataResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    it('should handle missing or invalid GraphQL data field', () => {
      // Response with missing gqlData field
      const missingGqlDataResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {},
      });
      expect(missingGqlDataResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });

      // Response with non-object gqlData field
      const invalidGqlDataResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: 'not an object',
        },
      });
      expect(invalidGqlDataResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    it('should handle missing or invalid repository field', () => {
      // Response with missing repository field
      const missingRepoResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {},
        },
      });
      expect(missingRepoResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });

      // Response with non-object repository field
      const invalidRepoResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {
            repository: 'not an object',
          },
        },
      });
      expect(invalidRepoResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    it('should handle missing or invalid dependencyVulnerabilityOccurrences field', () => {
      // Response with missing occurrences field
      const missingOccurrencesResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {
            repository: {},
          },
        },
      });
      expect(missingOccurrencesResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });

      // Response with non-object occurrences field
      const invalidOccurrencesResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {
            repository: {
              dependencyVulnerabilityOccurrences: 'not an object',
            },
          },
        },
      });
      expect(invalidOccurrencesResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
        },
        totalCount: 0,
      });
    });

    it('should handle empty vulnerability edges', () => {
      // Response with empty edges array but valid structure
      const emptyEdgesResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {
            repository: {
              dependencyVulnerabilityOccurrences: {
                edges: [],
                pageInfo: {
                  hasNextPage: true,
                  hasPreviousPage: false,
                  startCursor: 'start-cursor',
                  endCursor: 'end-cursor',
                },
                totalCount: 100,
              },
            },
          },
        },
      });

      // Should return empty vulnerabilities but preserve other data
      expect(emptyEdgesResult).toEqual({
        vulnerabilities: [],
        pageInfo: {
          hasNextPage: true,
          hasPreviousPage: false,
          startCursor: 'start-cursor',
          endCursor: 'end-cursor',
        },
        totalCount: 100,
      });
    });

    it('should process valid vulnerability data', () => {
      // Save a reference to the original method so we can restore it
      const originalIterateMethod = DeepSourceClient.prototype.constructor.iterateVulnerabilities;

      // Create test vulnerabilities generator function
      function* testGenerator() {
        yield { id: 'vuln1', severity: 'HIGH' };
        yield { id: 'vuln2', severity: 'MEDIUM' };
      }

      // Mock using a different approach to avoid infinite recursion
      // @ts-expect-error - Accessing and modifying private methods for testing
      DeepSourceClient.iterateVulnerabilities = function () {
        return testGenerator();
      };

      // Valid response with vulnerability data
      const validResult = TestableDeepSourceClient.testProcessVulnerabilityResponse({
        data: {
          data: {
            repository: {
              dependencyVulnerabilityOccurrences: {
                edges: [{ node: { id: 'vuln1' } }, { node: { id: 'vuln2' } }],
                pageInfo: {
                  hasNextPage: true,
                  hasPreviousPage: false,
                  startCursor: 'start-cursor',
                  endCursor: 'end-cursor',
                },
                totalCount: 50,
              },
            },
          },
        },
      });

      // Should return processed vulnerabilities and other data
      expect(validResult).toEqual({
        vulnerabilities: [
          { id: 'vuln1', severity: 'HIGH' },
          { id: 'vuln2', severity: 'MEDIUM' },
        ],
        pageInfo: {
          hasNextPage: true,
          hasPreviousPage: false,
          startCursor: 'start-cursor',
          endCursor: 'end-cursor',
        },
        totalCount: 50,
      });

      // Restore original method
      // @ts-expect-error - Restoring private method
      DeepSourceClient.iterateVulnerabilities = originalIterateMethod;
    });
  });

  describe('processVulnerabilityEdge', () => {
    it('should return null for null or undefined edge', () => {
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(null)).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(undefined)).toBeNull();
    });

    it('should return null for non-object edge', () => {
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge('string')).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(123)).toBeNull();
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(true)).toBeNull();
    });

    it('should return null when node is missing', () => {
      const edge = { cursor: 'some-cursor' }; // Edge without node property
      expect(TestableDeepSourceClient.testProcessVulnerabilityEdge(edge)).toBeNull();
    });

    it('should process valid vulnerability nodes', () => {
      // Mock isValidVulnerabilityNode and mapVulnerabilityOccurrence for this test
      const originalIsValid = TestableDeepSourceClient.testIsValidVulnerabilityNode;
      const originalMap = TestableDeepSourceClient.testMapVulnerabilityOccurrence;

      // Mock dependencies
      // @ts-expect-error - Mocking private static method
      DeepSourceClient.isValidVulnerabilityNode = jest.fn().mockReturnValue(true);
      // @ts-expect-error - Mocking private static method
      DeepSourceClient.mapVulnerabilityOccurrence = jest.fn().mockReturnValue({
        id: 'vuln-1',
        severity: 'HIGH',
        packageName: 'test-package',
      });

      const edge = {
        node: {
          id: 'vuln-node-1',
          severity: 'HIGH',
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityEdge(edge);

      expect(result).toEqual({
        id: 'vuln-1',
        severity: 'HIGH',
        packageName: 'test-package',
      });

      // Verify the mock was called with the node
      // @ts-expect-error - Accessing mocked method
      expect(DeepSourceClient.isValidVulnerabilityNode).toHaveBeenCalledWith(edge.node);
      // @ts-expect-error - Accessing mocked method
      expect(DeepSourceClient.mapVulnerabilityOccurrence).toHaveBeenCalledWith(edge.node);

      // Restore original methods after test
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.isValidVulnerabilityNode = originalIsValid;
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.mapVulnerabilityOccurrence = originalMap;
    });

    it('should return null for invalid vulnerability nodes', () => {
      // Mock isValidVulnerabilityNode to return false
      const originalIsValid = TestableDeepSourceClient.testIsValidVulnerabilityNode;

      // @ts-expect-error - Mocking private static method
      DeepSourceClient.isValidVulnerabilityNode = jest.fn().mockReturnValue(false);

      const edge = {
        node: {
          id: 'invalid-node',
        },
      };

      const result = TestableDeepSourceClient.testProcessVulnerabilityEdge(edge);
      expect(result).toBeNull();

      // Restore original method after test
      // @ts-expect-error - Restoring private static method
      DeepSourceClient.isValidVulnerabilityNode = originalIsValid;
    });
  });

  describe('iterateVulnerabilities', () => {
    // Mock the logger.warn to capture logs and prevent actual console output during tests
    let originalLogger: Record<string, unknown>;
    let mockWarn: jest.Mock;
    let originalIterateMethod: (...args: unknown[]) => Generator<unknown, void, unknown>;

    beforeEach(() => {
      // Save original logger
      // @ts-expect-error - Accessing private property
      originalLogger = DeepSourceClient.logger;

      // Save original iterateVulnerabilities method
      // @ts-expect-error - Accessing private property
      originalIterateMethod = DeepSourceClient.iterateVulnerabilities;

      // Create mock logger with warn function
      mockWarn = jest.fn();
      // @ts-expect-error - Setting private property
      DeepSourceClient.logger = {
        warn: mockWarn,
        debug: jest.fn(),
        info: jest.fn(),
        error: jest.fn(),
      };
    });

    afterEach(() => {
      // Restore original logger
      // @ts-expect-error - Restoring private property
      DeepSourceClient.logger = originalLogger;

      // Restore original iterateVulnerabilities method
      // @ts-expect-error - Restoring private method
      DeepSourceClient.iterateVulnerabilities = originalIterateMethod;
    });

    it('should log a warning and return for non-array input', () => {
      // We need to implement our own version to test this specific behavior
      // without calling the original method (to avoid infinite recursion)

      // Create a direct implementation for this test
      function* testNonArrayFunction() {
        const input = 'not an array';
        if (!Array.isArray(input)) {
          // @ts-expect-error - Accessing mock logger
          DeepSourceClient.logger.warn(
            'Invalid edges data: expected an array but got',
            typeof input
          );
          return;
        }
        yield null; // This won't be reached
      }

      // Use the test function
      const generator = testNonArrayFunction();
      const result = Array.from(generator);

      // Check that it logged a warning and returned empty array
      expect(result).toEqual([]);
      expect(mockWarn).toHaveBeenCalledWith(
        'Invalid edges data: expected an array but got',
        'string'
      );
    });

    it('should log a warning and break when exceeding max iterations', () => {
      // Save original MAX_ITERATIONS value
      const originalMaxIterations = TestableDeepSourceClient.MAX_ITERATIONS;

      try {
        // Set a very low MAX_ITERATIONS value for testing
        TestableDeepSourceClient.MAX_ITERATIONS = 1;

        // Implement our own version of the method to test this behavior directly
        function* maxIterationsTestFunction() {
          const edges = [
            { node: { id: 'vuln1' } },
            { node: { id: 'vuln2' } },
            { node: { id: 'vuln3' } },
          ];

          let iterationCount = 0;
          const MAX_ITERATIONS = TestableDeepSourceClient.MAX_ITERATIONS;

          for (const edge of edges) {
            // Check if we're exceeding the max iteration count
            if (iterationCount > MAX_ITERATIONS) {
              // @ts-expect-error - Accessing mock logger
              DeepSourceClient.logger.warn(
                `Exceeded maximum iteration count (${MAX_ITERATIONS}). Stopping processing.`
              );
              break;
            }

            iterationCount++;
            yield { id: edge.node.id, severity: 'HIGH' };
          }
        }

        // Replace the original with our test function
        // @ts-expect-error - Setting private method for test
        DeepSourceClient.iterateVulnerabilities = function () {
          return maxIterationsTestFunction();
        };

        // Execute the generator with a simple array
        const results = Array.from(maxIterationsTestFunction());

        // Should log a warning about exceeding max iterations
        expect(mockWarn).toHaveBeenCalledWith(
          `Exceeded maximum iteration count (${TestableDeepSourceClient.MAX_ITERATIONS}). Stopping processing.`
        );

        // Since MAX_ITERATIONS is set to 1, we can process up to 2 items
        // (One item at iteration 0, and one at iteration 1)
        expect(results.length).toBeLessThanOrEqual(TestableDeepSourceClient.MAX_ITERATIONS + 1);
      } finally {
        // Restore original max iterations value
        TestableDeepSourceClient.MAX_ITERATIONS = originalMaxIterations;
      }
    });

    it('should handle errors during vulnerability processing', () => {
      // Implement our own version of the method to test this behavior directly
      function* errorHandlingTestFunction() {
        const edges = [
          { node: { id: 'vuln1' } },
          { node: { id: 'error-edge' } }, // This will cause an error
          { node: { id: 'vuln2' } },
        ];

        for (const edge of edges) {
          try {
            // Simulate processVulnerabilityEdge behavior
            if (edge.node.id === 'error-edge') {
              throw new Error('Test processing error');
            }

            yield { id: edge.node.id, severity: 'HIGH' };
          } catch (error) {
            // @ts-expect-error - Accessing mock logger
            DeepSourceClient.logger.warn('Error processing vulnerability edge:', error);
            // Continue to the next edge
            continue;
          }
        }
      }

      // Execute the generator and convert to array
      const results = Array.from(errorHandlingTestFunction());

      // Should skip the error edge and continue processing
      expect(results.length).toBe(2);
      expect(results[0].id).toBe('vuln1');
      expect(results[1].id).toBe('vuln2');

      // Should log a warning about the error
      expect(mockWarn).toHaveBeenCalledWith(
        'Error processing vulnerability edge:',
        expect.any(Error)
      );
    });

    it('should skip null vulnerability results', () => {
      // Implement our own version of the method to test this behavior directly
      function* nullSkippingTestFunction() {
        const edges = [
          { node: { id: 'vuln1' } },
          { node: { id: 'invalid-edge' } }, // This will produce null
          { node: { id: 'vuln2' } },
        ];

        for (const edge of edges) {
          // Simulate processVulnerabilityEdge behavior
          let result = null;

          // Determine the result based on the edge type
          if (edge.node.id !== 'invalid-edge') {
            result = { id: edge.node.id, severity: 'HIGH' };
          }

          // Skip null results (similar to the original implementation)
          if (result !== null) {
            yield result;
          }
        }
      }

      // Execute the generator and convert to array
      const results = Array.from(nullSkippingTestFunction());

      // Should skip the null result and only return valid ones
      expect(results.length).toBe(2);
      expect(results[0].id).toBe('vuln1');
      expect(results[1].id).toBe('vuln2');
    });
  });
});
